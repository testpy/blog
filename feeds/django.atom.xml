<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>testpy</title><link href="/" rel="alternate"></link><link href="/feeds/django.atom.xml" rel="self"></link><id>/</id><updated>2013-11-05T00:00:00+02:00</updated><entry><title>10 pragmatic guidelines to maximize test usefulness</title><link href="/10-pragmatic-guidelines-to-maximize-test-usefulness/" rel="alternate"></link><updated>2013-11-05T00:00:00+02:00</updated><author><name>Dan Claudiu Pop</name></author><id>tag:,2013-11-05:10-pragmatic-guidelines-to-maximize-test-usefulness/</id><summary type="html">&lt;iframe width="420" height="315" src="//www.youtube.com/embed/91-LiEb3sPE" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;&lt;div class="section" id="abstract"&gt;
&lt;h2&gt;ABSTRACT&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;WHAT MAKES GOOD TESTS?&lt;/strong&gt;&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Tests should be as simple as possible.&lt;/li&gt;
&lt;li&gt;Tests should run as quickly as possible.&lt;/li&gt;
&lt;li&gt;Tests should avoid coupling with other tests.&lt;/li&gt;
&lt;li&gt;Tests should communicate intent.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;CANONICAL FORM OF A TEST&lt;/strong&gt;&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Setup pre-conditions.&lt;/li&gt;
&lt;li&gt;Perform operation under test.&lt;/li&gt;
&lt;li&gt;Make assertions.&lt;/li&gt;
&lt;li&gt;Benefits of following canonical form.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;TESTING TOOLS&lt;/strong&gt;&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Factories (instead of fixtures).&lt;/li&gt;
&lt;li&gt;Coverage.py&lt;/li&gt;
&lt;li&gt;django-nose + multiprocess&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;GUIDELINES&lt;/strong&gt;&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Tests should be as simple as possible.&lt;/li&gt;
&lt;li&gt;Each test method tests one thing, and one thing only.&lt;/li&gt;
&lt;li&gt;Only set up the minimum needed pre-conditions for your test.&lt;/li&gt;
&lt;li&gt;Create your pre-conditions explicitly - don't use shared helper methods outside your module.&lt;/li&gt;
&lt;li&gt;Name your TestCase methods to indicate what they actually test.&lt;/li&gt;
&lt;li&gt;Use factories, not fixtures.&lt;/li&gt;
&lt;li&gt;Use django.tests.TestCase instead of unittest2.TestCase&lt;/li&gt;
&lt;li&gt;Create mixins, not shared TestCases.&lt;/li&gt;
&lt;li&gt;Segment your tests.&lt;/li&gt;
&lt;li&gt;Don't use setupClass() or tearDownClass()&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary><category term="django"></category><category term="talks"></category></entry><entry><title>Writing tests with django and selenium</title><link href="/writing-tests-with-django-and-selenium/" rel="alternate"></link><updated>2013-04-25T00:00:00+03:00</updated><author><name>Ramona Suciu</name></author><id>tag:,2013-04-25:writing-tests-with-django-and-selenium/</id><summary type="html">&lt;p&gt;Getting our Selenium tests to run faster can be complicated at times, because
there are a number of factors to be taken into consideration. Debugging these
tests is time consuming and the end result is almost always the same one - a
large part of the tests needs to be refactored.&lt;/p&gt;
&lt;p&gt;Luckily, for projects implemented with Django, we have the possibility to
explore a wide range of testing solutions, backed up by an active internet
community. Instead of always trying to use Selenium as a standalone solution,
we could analyze the possibility of having those tests integrated in our Django
project, and hence, be able to run with a simple command, all tests. By all
tests, I mean unit tests and functional tests.&lt;/p&gt;
&lt;p&gt;For a practical example, please have a look at this &lt;a class="reference external" href="https://github.com/ramonasuciu/django_selenium_tests"&gt;github&lt;/a&gt; repo. This is just an
example of how Selenium tests can be integrated with Django, with the use of
&lt;tt class="docutils literal"&gt;LiveServerTestCase&lt;/tt&gt; class. Make sure to run &lt;tt class="docutils literal"&gt;pip install &lt;span class="pre"&gt;-r&lt;/span&gt;
requirements.txt&lt;/tt&gt; in a virtualenv and you’re good to go.&lt;/p&gt;
&lt;p&gt;The application used for testing is &lt;a class="reference external" href="https://bitbucket.org/ubernostrum/django-registration/"&gt;django-registration&lt;/a&gt;, which provides
enough support for developing functional tests. We inserted a js library
(password_strength_plugin.js) to better illustrate the need of Selenium
(JS/CSS/HTML focused) automated tests.&lt;/p&gt;
&lt;p&gt;The advantages of this approach are numerous - you are able to test the
build as well, not only the deploy. Tests are faster, and, if you decide to
write your tests using a page object pattern method, then debugging will become
easier, as you’ll be able to faster track failures and their causes.&lt;/p&gt;
</summary><category term="functional"></category><category term="django"></category><category term="selenium"></category></entry></feed>